<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Car Game with Realistic Supra MK4</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://unpkg.com/three@0.134.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add basic lighting for realism
        const ambientLight = new THREE.AmbientLight(0x404040); // Soft light
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // Create a car group
        const car = new THREE.Group();

        // Try to load the Supra MK4 model
        let supraModelLoaded = false;
        const loader = new THREE.GLTFLoader();
        loader.load(
            'supra_mk4.glb', // Path to your model file
            (gltf) => {
                const supraModel = gltf.scene;
                // Adjust the model's scale, position, and rotation
                supraModel.scale.set(0.01, 0.01, 0.01); // Adjust scale (models vary in size)
                supraModel.position.y = 0.5; // Adjust height to sit on the ground
                supraModel.rotation.y = Math.PI; // Rotate to face forward

                // Apply orange color to the model (override existing materials)
                supraModel.traverse((child) => {
                    if (child.isMesh) {
                        child.material = new THREE.MeshPhongMaterial({ color: 0xff4500, shininess: 100 }); // Orange color
                    }
                });

                car.add(supraModel);
                supraModelLoaded = true;
                console.log("Supra MK4 model loaded successfully!");
            },
            (xhr) => {
                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
            },
            (error) => {
                console.error('An error occurred while loading the model:', error);
                // Fallback to improved geometric approximation if model fails to load
                createGeometricSupra();
            }
        );

        // Fallback: Improved geometric approximation of the Supra MK4 with smoother shapes
        function createGeometricSupra() {
            // Create a smoother body shape using ExtrudeGeometry
            const bodyShape = new THREE.Shape();
            bodyShape.moveTo(-0.6, 0); // Bottom left
            bodyShape.lineTo(0.6, 0);  // Bottom right
            bodyShape.quadraticCurveTo(0.6, 0.3, 0.5, 0.4); // Right curve up
            bodyShape.lineTo(-0.5, 0.4); // Top straight
            bodyShape.quadraticCurveTo(-0.6, 0.3, -0.6, 0); // Left curve down

            const extrudeSettings = { depth: 2.5, bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.05 };
            const bodyGeometry = new THREE.ExtrudeGeometry(bodyShape, extrudeSettings);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xff4500, shininess: 100 }); // Orange color
            const carBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
            carBody.position.y = 0.3;
            carBody.position.z = -1.25; // Center the extruded body
            car.add(carBody);

            // Hood (sloped front)
            const hoodShape = new THREE.Shape();
            hoodShape.moveTo(-0.5, 0);
            hoodShape.lineTo(0.5, 0);
            hoodShape.lineTo(0.4, 0.3);
            hoodShape.lineTo(-0.4, 0.3);
            hoodShape.lineTo(-0.5, 0);

            const hoodExtrudeSettings = { depth: 0.8, bevelEnabled: true, bevelThickness: 0.02, bevelSize: 0.02 };
            const hoodGeometry = new THREE.ExtrudeGeometry(hoodShape, hoodExtrudeSettings);
            const hood = new THREE.Mesh(hoodGeometry, bodyMaterial);
            hood.position.set(0, 0.4, 0.5);
            car.add(hood);

            // Windshield (black to simulate glass)
            const windshieldGeometry = new THREE.BoxGeometry(0.9, 0.05, 0.5);
            const windshieldMaterial = new THREE.MeshPhongMaterial({ color: 0x111111 });
            const windshield = new THREE.Mesh(windshieldGeometry, windshieldMaterial);
            windshield.position.set(0, 0.55, 0.3);
            windshield.rotation.x = -Math.PI / 4;
            car.add(windshield);

            // Hood vents
            const ventGeometry = new THREE.BoxGeometry(0.2, 0.05, 0.3);
            const ventMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const vent1 = new THREE.Mesh(ventGeometry, ventMaterial);
            const vent2 = new THREE.Mesh(ventGeometry, ventMaterial);
            vent1.position.set(-0.3, 0.65, 0.9);
            vent2.position.set(0.3, 0.65, 0.9);
            car.add(vent1, vent2);

            // Spoiler (prominent wing)
            const spoilerGeometry = new THREE.BoxGeometry(1.2, 0.05, 0.2);
            const spoilerMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const spoiler = new THREE.Mesh(spoilerGeometry, spoilerMaterial);
            spoiler.position.set(0, 0.65, -1.3);
            car.add(spoiler);

            // Simplified decals (green and blue shapes)
            const decalGeometry = new THREE.BoxGeometry(0.05, 0.05, 1.2);
            const greenDecalMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 }); // Green
            const blueDecalMaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff }); // Blue
            const greenDecal1 = new THREE.Mesh(decalGeometry, greenDecalMaterial);
            const greenDecal2 = new THREE.Mesh(decalGeometry, greenDecalMaterial);
            const blueDecal1 = new THREE.Mesh(decalGeometry, blueDecalMaterial);
            const blueDecal2 = new THREE.Mesh(decalGeometry, blueDecalMaterial);
            greenDecal1.position.set(-0.65, 0.45, 0);
            greenDecal2.position.set(0.65, 0.45, 0);
            blueDecal1.position.set(-0.65, 0.45, 0.5);
            blueDecal2.position.set(0.65, 0.45, 0.5);
            car.add(greenDecal1, greenDecal2, blueDecal1, blueDecal2);

            // Headlights (white rectangles)
            const headlightGeometry = new THREE.BoxGeometry(0.1, 0.05, 0.05);
            const headlightMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
            const headlight1 = new THREE.Mesh(headlightGeometry, headlightMaterial);
            const headlight2 = new THREE.Mesh(headlightGeometry, headlightMaterial);
            headlight1.position.set(-0.4, 0.35, 1.2);
            headlight2.position.set(0.4, 0.35, 1.2);
            car.add(headlight1, headlight2);

            // Wheels (larger for sporty look)
            const wheelGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.2, 32);
            const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const wheels = [];
            for (let i = 0; i < 4; i++) {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2;
                wheels.push(wheel);
                car.add(wheel);
            }
            wheels[0].position.set(-0.7, 0.25, 0.9);
            wheels[1].position.set(0.7, 0.25, 0.9);
            wheels[2].position.set(-0.7, 0.25, -0.9);
            wheels[3].position.set(0.7, 0.25, -0.9);
        }

        scene.add(car);

        // Grass background
        const grassGeometry = new THREE.PlaneGeometry(200, 200);
        const grassMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
        const grass = new THREE.Mesh(grassGeometry, grassMaterial);
        grass.rotation.x = -Math.PI / 2;
        grass.position.y = 0;
        scene.add(grass);

        // Straight road with borders
        const roadWidth = 5;
        const roadLength = 100;
        const roadGeometry = new THREE.PlaneGeometry(roadWidth, roadLength);
        const roadMaterial = new THREE.MeshPhongMaterial({ color: 0x555555 });
        const road = new THREE.Mesh(roadGeometry, roadMaterial);
        road.rotation.x = -Math.PI / 2;
        road.position.y = 0.02;
        scene.add(road);

        // Lane markings (white dashes)
        const laneGeometry = new THREE.PlaneGeometry(0.2, 1);
        const laneMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
        for (let z = -50; z < 50; z += 2) {
            const laneMark = new THREE.Mesh(laneGeometry, laneMaterial);
            laneMark.rotation.x = -Math.PI / 2;
            laneMark.position.set(0, 0.03, z);
            scene.add(laneMark);
        }

        // Red and white striped borders
        const borderWidth = 0.5;
        const borderGeometry = new THREE.PlaneGeometry(borderWidth, roadLength);
        const borderLeft = new THREE.Mesh(borderGeometry, new THREE.MeshPhongMaterial({ color: 0xff0000 }));
        const borderRight = new THREE.Mesh(borderGeometry, new THREE.MeshPhongMaterial({ color: 0xff0000 }));
        borderLeft.rotation.x = -Math.PI / 2;
        borderRight.rotation.x = -Math.PI / 2;
        borderLeft.position.set(-roadWidth / 2 - borderWidth / 2, 0.02, 0);
        borderRight.position.set(roadWidth / 2 + borderWidth / 2, 0.02, 0);
        scene.add(borderLeft, borderRight);

        // White stripes on borders
        const stripeGeometry = new THREE.PlaneGeometry(borderWidth / 2, 1);
        const stripeMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
        for (let z = -50; z < 50; z += 2) {
            const stripeLeft = new THREE.Mesh(stripeGeometry, stripeMaterial);
            const stripeRight = new THREE.Mesh(stripeGeometry, stripeMaterial);
            stripeLeft.rotation.x = -Math.PI / 2;
            stripeRight.rotation.x = -Math.PI / 2;
            stripeLeft.position.set(-roadWidth / 2 - borderWidth / 2, 0.03, z);
            stripeRight.position.set(roadWidth / 2 + borderWidth / 2, 0.03, z);
            scene.add(stripeLeft, stripeRight);
        }

        // Camera view system with mouse control
        let cameraMode = 'thirdPerson';
        let yaw = 0;
        let pitch = 0;
        const sensitivity = 0.005;

        document.addEventListener('click', () => {
            renderer.domElement.requestPointerLock();
        });

        document.addEventListener('mousemove', (event) => {
            if (document.pointerLockElement === renderer.domElement) {
                yaw -= event.movementX * sensitivity;
                pitch -= event.movementY * sensitivity;
                pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
            }
        });

        function updateCamera() {
            const carPosition = car.position;

            if (cameraMode === 'thirdPerson') {
                const distance = 8;
                const height = 3;
                camera.position.set(
                    carPosition.x + distance * Math.sin(yaw) * Math.cos(pitch),
                    carPosition.y + height + distance * Math.sin(pitch),
                    carPosition.z + distance * Math.cos(yaw) * Math.cos(pitch)
                );
                camera.lookAt(carPosition);
            } else if (cameraMode === 'firstPerson') {
                camera.position.set(
                    carPosition.x,
                    carPosition.y + 1.5,
                    carPosition.z + 1
                );
                camera.rotation.set(pitch, yaw + car.rotation.y, 0);
            } else if (cameraMode === 'topDown') {
                camera.position.set(
                    carPosition.x,
                    carPosition.y + 15,
                    carPosition.z
                );
                camera.lookAt(carPosition);
                camera.rotation.x = -Math.PI / 2;
            }
        }

        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case '1': cameraMode = 'thirdPerson'; break;
                case '2': cameraMode = 'firstPerson'; break;
                case '3': cameraMode = 'topDown'; break;
            }
        });

        // Movement variables
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        const speed = 0.1;
        let carRotation = 0;

        // Keyboard controls for movement
        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'ArrowUp': moveForward = true; break;
                case 'ArrowDown': moveBackward = true; break;
                case 'ArrowLeft': moveLeft = true; break;
                case 'ArrowRight': moveRight = true; break;
            }
            socket.emit('playerInput', { moveForward, moveBackward, moveLeft, moveRight, carRotation });
        });

        document.addEventListener('keyup', (event) => {
            switch (event.key) {
                case 'ArrowUp': moveForward = false; break;
                case 'ArrowDown': moveBackward = false; break;
                case 'ArrowLeft': moveLeft = false; break;
                case 'ArrowRight': moveRight = false; break;
            }
            socket.emit('playerInput', { moveForward, moveBackward, moveLeft, moveRight, carRotation });
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // If the model hasn't loaded yet and no fallback has been created, create the fallback
            if (!supraModelLoaded && car.children.length === 0) {
                createGeometricSupra();
            }

            // Move and rotate the car
            if (moveForward) {
                car.position.z -= speed * Math.cos(carRotation);
                car.position.x -= speed * Math.sin(carRotation);
            }
            if (moveBackward) {
                car.position.z += speed * Math.cos(carRotation);
                car.position.x += speed * Math.sin(carRotation);
            }
            if (moveLeft) carRotation += 0.05;
            if (moveRight) carRotation -= 0.05;

            car.rotation.y = carRotation;

            // Update camera based on the current mode
            updateCamera();

            renderer.render(scene, camera);
        }
        animate();

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Handle player updates from the server
        socket.on('playerUpdate', (players) => {
            for (const id in players) {
                if (id !== socket.id) {
                    const player = players[id];
                    const playerCar = new THREE.Group();
                    const playerCarModel = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
                    playerCar.add(playerCarModel);
                    playerCar.position.set(player.position.x, player.position.y, player.position.z);
                    playerCar.rotation.y = player.rotation;
                    scene.add(playerCar);
                }
 ...